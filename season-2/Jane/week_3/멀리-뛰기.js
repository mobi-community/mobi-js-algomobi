/*
@ 풀이 방법 생각하기
1. n만큼의 1로 구성된 배열을 만든다. (cnt = 1로 시작)
2. 앞에서 두 개가 1이면 두 개를 삭제한 후 뒤에 2 push
3. 남은 1만큼 cnt++
4. 1이 두 개가 남지 않을 때까지 반복
=====================================================
1칸) 1 (1)
2칸) 1 1 / 2 (2)
3칸) 1 1 1 / 1 2 / 2 1 (3)
4칸) 1 1 1 1 / 1 1 2 / 1 2 1 / 2 1 1 / 2 2 (5)
5칸) 1 1 1 1 1 / 1 1 1 2 / 1 1 2 1 / 1 2 1 1 / 2 1 1 1 / 1 2 2 / 2 1 2 / 2 2 1 (8)
6칸) 1 1 1 1 1 1 / 1 1 1 1 2 / 1 1 1 2 1 / 1 1 2 1 1 / 1 2 1 1 1 / 2 1 1 1 1 /
     1 1 2 2 / 1 2 1 2 / 2 1 1 2 / 2 1 2 1 / 2 2 1 1 / 2 2 2 (12)
> 1 2 3 5 8 12
1, 2, 2 + 1, 2 + 1 + 2, 2 + 1 + 2 + 3, 2 + 1 + 2 + 3 + 4
*/

/*
1. 피보나치 수열로 풀이하기
2. 이때 인접한 두 항의 값만 알면 되므로 두 항을 나타내는 변수를 생성한다.
3. 3번째 항부터 for문을 돌려 원하는 값을 도출한다.
*/

function solution(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  let a = 1,
    b = 2;
  for (let i = 3; i <= n; i++) {
    // 비구조화 할당 방식으로 값을 바꿔서 할당할 수 있다.
    [a, b] = [b, a];
    b = (b + a) % 1234567;
  }
  return b;
}

/*
@ 실패한 풀이
- 피보나치 수열을 제대로 이해하지 못했다.
*/
function solution(n) {
  let arr = Array.from({ length: n }, () => 1);
  let cnt = 1;
  while (arr[0] + arr[1] === 2) {
    arr = arr.slice(2);
    arr.push(2);
    cnt += arr.filter((el) => el === 1).length + 1;
  }
  return cnt % 1234567;
}
